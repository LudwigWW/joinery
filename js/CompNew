function addGCodePartsC(inString, params, placeList, commandObjs, guidingCmdObj, depthAdjustment, print_Offset_X, reverse=false, durations={durationEstimate:0, durationEstimateTotal:0, toComeEstimate:0}) {
	// // console.log({MSG:"Adding GCode", commandObj:commandObj, depthAdjustment:depthAdjustment, placeList:placeList, params:params});
	// // console.log("outString: " + outString.length);

	outString = "";

	// commandObj = commandObjs[0];
	// needleObj = commandObjs[1];

	function handlePreCode(commandObj, place, depthAdjustment, durations) {
		let preCodeString = `G1 Z${commandObj.zClearing} F3000\n`; // Safety lift
		preCodeString += `G1 X${(place.x + print_Offset_X + commandObj.offset.x).toFixed(3)} Y${(place.y + depthAdjustment + commandObj.offset.y).toFixed(3)} F7200\n`; // XY positioning
		preCodeString += `G1 Z${commandObj.zStart} F3000\n`; // Z positioning
		preCodeString += getCodeWRetraction(commandObj.preCode, chosenPrinter, durations.durationEstimate, durations.durationEstimateTotal, durations.toComeEstimate);
		handleFirstPlace = false;
		return preCodeString;
	}
	
	function produceCode(commandObj, place, depthAdjustment, durations, skip=false, onlyAim=false, last=false, first=false) {
		let addString = "";
		addString += `G1 Z${commandObj.zClearing} F3000\n`; // Safety lift
		addString += `G1 X${(place.x + print_Offset_X + commandObj.offset.x).toFixed(3)} Y${(place.y + depthAdjustment + commandObj.offset.y).toFixed(3)} F7200\n`; // XY positioning
		addString += `G1 Z${commandObj.zStart} F3000\n`; // Z positioning
		
		if (onlyAim) {
			return addString;
		}
		if (skip) {
			addString += getCodeWRetraction(commandObj.skipGCode, chosenPrinter, durations.durationEstimate, durations.durationEstimateTotal, durations.toComeEstimate);
		}
		else if (last) {
			addString += getCodeWRetraction(commandObj.postCode, chosenPrinter, durations.durationEstimate, durations.durationEstimateTotal, durations.toComeEstimate);
		}
		else if (first) {
			addString += getCodeWRetraction(commandObj.preCode, chosenPrinter, durations.durationEstimate, durations.durationEstimateTotal, durations.toComeEstimate);
			handleFirstPlace = false;
		}
		else {
			addString += getCodeWRetraction(commandObj.gcode, chosenPrinter, durations.durationEstimate, durations.durationEstimateTotal, durations.toComeEstimate);
		}
		addString = addString;
		return addString;
	}
	
	var lastPlace = [];
	var patternIndex = 0;
	let placeCounter = 0;
	let handleFirstPlace = false; // TODO: Make one first place handled per commandObj
	let directional = false;

	// commandObjs.forEach(function (cmdObj) {
		if (guidingCmdObj.preCode) {
			handleFirstPlace = true;
		}
		if (guidingCmdObj.directional == true) {
			directional = true;
		}
	// });
	// for (let i = -5; i < 5; i++) { 
	// 	// console.log(mod(i, commandObj.pattern.length));
	// }

	let pattern = [...guidingCmdObj.pattern];
	console.log('source-pattern: ', guidingCmdObj.pattern);
	let reversePatternOffsetLength = null;

	let placeListLocal = [...placeList];

	let handledList = [...placeList];

	if (pattern.length == 0) {
		// pattern = [1];
	}
	if (reverse) {
		pattern = pattern.reverse();
		console.log('reversed-pattern: ', pattern);
		pattern = pattern.map(function(item) {if (item !== 0.5 && item !== 0) item = -item; return item;});
		reversePatternOffsetLength = placeListLocal.length % pattern.length;
		for (let i = 0; i < reversePatternOffsetLength; i++) {
			pattern.push(pattern.shift());
		} 
		placeListLocal = placeListLocal.reverse();
	}

	for (let place of placeListLocal) {
		place.handled = false;
	}

	// debug output for the hole handling and order
	console.log({reverse:reverse, OffsetPattern:pattern, placeListLocal:placeListLocal, patternOffset:reversePatternOffsetLength});

	// This puts it before the needle...
	// if (placeListLocal.length > 0 && commandObj.preCode) { // TODO: This assumes the first place is actually used, which is only true for patterns that use all holes
	// 	outString += `G1 Z${commandObj.zClearing} F3000\n`; // Safety lift
	// 	outString += `G1 X${(placeListLocal[0].x + print_Offset_X + commandObj.offset.x).toFixed(3)} Y${(placeListLocal[0].y + depthAdjustment + commandObj.offset.y).toFixed(3)} F7200\n`; // XY positioning
	// 	outString += `G1 Z${commandObj.zStart} F3000\n`; // Z positioning
	// 	outString += getCodeWRetraction(commandObj.preCode, chosenPrinter);
	// }

	let placeIndex = 0;

	for (let place of placeListLocal) {
		// outString += `G1 Z${commandObj.zClearing} F3000\n`; // Safety lift
		// outString += `G1 X${(place.x + print_Offset_X + commandObj.offset.x).toFixed(3)} Y${(place.y + depthAdjustment + commandObj.offset.y).toFixed(3)} F7200\n`; // XY positioning
		// outString += `G1 Z${commandObj.zStart} F3000\n`; // Z positioning
		
		if (directional == false) {
			if (pattern[patternIndex] !== 0) {
				// // outString += commandObj.gcode; // Adding plug&play/drag&drop G-Code
				// outString += produceCode(needleObj, place, depthAdjustment, durations);
				// if (handleFirstPlace) {
				// 	outString += handlePreCode(commandObj, place, depthAdjustment, durations);
				// }
				// outString += produceCode(commandObj, place, depthAdjustment, durations, false);


				commandObjs.forEach(function (cmdObj) {
					if (cmdObj.preCode && handleFirstPlace) {
						outString += handlePreCode(cmdObj, place, depthAdjustment, durations);
					}
					outString += produceCode(cmdObj, place, depthAdjustment, durations, false);
				});

			}
		}
		else {
			if (Math.abs(pattern[patternIndex]) == 0) {
				// If following pattern spots would connect to this, but line ends early, add skip-gcode
				for (let i = patternIndex; i < (patternIndex+pattern.length); i++) {  // check whole pattern
					const patternPlace = mod(i, pattern.length);
					if (((placeCounter+i-patternIndex+1) > placeList.length)) { // only parts of the pattern that would come after line ends 
						if ((Math.abs(pattern[patternPlace]) > 0.5)) { // Only if the pattern actually connects to something
							if (mod((i - pattern[patternPlace]), pattern.length) == patternIndex)  { // Check if it connects to the current point
								// outString += commandObj.skipGCode;

								commandObjs.forEach(function (cmdObj) {
									if (cmdObj.needle) {
										if (place.handled == false) {
											outString += produceCode(cmdObj, place, depthAdjustment, durations);
											place.handled = true;
										}
									} else {
										if (cmdObj.preCode && handleFirstPlace) {
											outString += handlePreCode(cmdObj, place, depthAdjustment, durations); // TODO: handling skip and preCode together?
										}
										outString += produceCode(cmdObj, place, depthAdjustment, durations, true);
									}
								});
								break;

								// if (place.handled == false) {
								// 	outString += produceCode(needleObj, place, depthAdjustment, durations);
								// 	place.handled = true;
								// }
								// if (handleFirstPlace) {
								// 	outString += handlePreCode(commandObj, place, depthAdjustment, durations); // TODO: handling skip and preCode together?
								// }
								// outString += produceCode(commandObj, place, depthAdjustment, durations, true);
								// break;
							}
						}
					}
				}
				// if ((placeCounter+1) == placeList.length) { // edge case, print counter on last hole when hole would normally be skipped
				// 	outString += commandObj.skipGCode;
				// }

			} else if (pattern[patternIndex] == 0.5) {
				if (((placeCounter+pattern.length) > (placeList.length)) || ((placeCounter-pattern.length) < -1)) {
					// outString += commandObj.skipGCode;
					commandObjs.forEach(function (cmdObj) {
						if (cmdObj.needle) {
							if (place.handled == false) {
								outString += produceCode(cmdObj, place, depthAdjustment, durations);
								place.handled = true;
							}
						} else {
							if (cmdObj.preCode && handleFirstPlace) {
								outString += handlePreCode(cmdObj, place, depthAdjustment, durations); // TODO: handling skip and preCode together?
							}
							outString += produceCode(cmdObj, place, depthAdjustment, durations, true);
						}
					});
					// if (place.handled == false) {
					// 	outString += produceCode(needleObj, place, depthAdjustment, durations);
					// 	place.handled = true;
					// }
					// if (handleFirstPlace) {
					// 	outString += handlePreCode(commandObj, place, depthAdjustment, durations); // TODO: handling skip and preCode together?
					// }
					// outString += produceCode(commandObj, place, depthAdjustment, durations, true);
				}

			} else { 
				
				// if (pattern[patternIndex] > lastPlace.length) { // No place saved yet, can't connect here, so add skip-gcode
				console.log({negativeCheck:pattern[patternIndex] < 0, fitsCheck:placeIndex-pattern[patternIndex] > placeList.length, patternIndex:patternIndex, placeIndex:placeIndex, placeCounter:placeCounter, placeListLength:placeList.length});
				if (pattern[patternIndex] > lastPlace.length || (pattern[patternIndex] < 0 && placeIndex-pattern[patternIndex] >= placeList.length)) { // No place saved yet, can't connect here, so add skip-gcode // TODO-Done?: This only makes sense in "forward" direction though, otherwise will end up with skip code in addition to the actual? 
					let noOut = true;
					for (let i = patternIndex; i < (patternIndex+pattern.length); i++) { // check whole pattern
						const patternPlace = mod(i, pattern.length);
						if ((Math.abs(pattern[patternPlace]) > 0.5) && (mod((i - pattern[patternPlace]), pattern.length) == patternIndex)) {
							noOut = false;
						}
					}
					if (noOut)  {
						commandObjs.forEach(function (cmdObj) {
							if (cmdObj.needle) {
								if (place.handled == false) {
									outString += produceCode(cmdObj, place, depthAdjustment, durations);
									place.handled = true;
								}
							} else {
								if (cmdObj.preCode && handleFirstPlace) {
									outString += handlePreCode(cmdObj, place, depthAdjustment, durations); // TODO: handling skip and preCode together?
								}
								outString += produceCode(cmdObj, place, depthAdjustment, durations, true);
							}
						});

						// // outString += commandObj.skipGCode;
						// if (place.handled == false) {
						// 	outString += produceCode(needleObj, place, depthAdjustment, durations);
						// 	place.handled = true;
						// }
						// if (handleFirstPlace) {
						// 	outString += handlePreCode(commandObj, place, depthAdjustment, durations); // TODO: handling skip and preCode together?
						// }
						// outString += produceCode(commandObj, place, depthAdjustment, durations, true);
					}
				}

				// "Default" outcome (for rotation variant patterns)
				
				else {
					let fromLocation = placeListLocal[placeIndex - pattern[patternIndex]];
					console.log({patternTargeting:pattern[patternIndex], fromLocation:placeIndex - pattern[patternIndex], lastPlacesLength:lastPlace.length, placeIndex:placeIndex, placeCounter:placeCounter, placeListLength:placeList.length});

					commandObjs.forEach(function (cmdObj) {
						if (cmdObj.needle) {
							if (place.handled == false) {
								outString += produceCode(cmdObj, place, depthAdjustment, durations);
								place.handled = true;
							}
							if (fromLocation.handled == false) {
								outString += produceCode(cmdObj, fromLocation, depthAdjustment, durations);
								fromLocation.handled = true;
							}
						} else {
							if (cmdObj.preCode && handleFirstPlace) {
								outString += handlePreCode(cmdObj, place, depthAdjustment, durations); // first target place should be the actual first hole
							}
							outString += produceCode(cmdObj, place, depthAdjustment, durations, false, true); // only aim
							outString += getCodeWRetraction(aimGCodePart(place, fromLocation, cmdObj), chosenPrinter, durations.durationEstimate, durations.durationEstimateTotal, durations.toComeEstimate); // rotate and add aimed plug&play G-Code

						}
					});

					// if (place.handled == false) {
					// 	outString += produceCode(needleObj, place, depthAdjustment, durations);
					// 	place.handled = true;
					// }
					// if (fromLocation.handled == false) {
					// 	outString += produceCode(needleObj, fromLocation, depthAdjustment, durations);
					// 	fromLocation.handled = true;
					// }
					// if (handleFirstPlace) {
					// 	outString += handlePreCode(commandObj, fromLocation, depthAdjustment, durations); // first target place should be the actual first hole
					// }
					// outString += produceCode(commandObj, place, depthAdjustment, durations, false, true); // only aim
					// outString += getCodeWRetraction(aimGCodePart(place, fromLocation, commandObj), chosenPrinter, durations.durationEstimate, durations.durationEstimateTotal, durations.toComeEstimate); // rotate and add aimed plug&play G-Code
				}
			}
		}

		placeIndex += 1;
		patternIndex += 1;
		if (patternIndex >= pattern.length) patternIndex = 0;

		lastPlace.push(place);
		placeCounter += 1;

		commandObjs.forEach(function (cmdObj) {
			if (cmdObj.duration) durations.durationEstimate -= cmdObj.duration;
		});
		// if (commandObj.duration) durations.durationEstimate -= commandObj.duration;
		// if (needleObj.duration) durations.durationEstimate -= needleObj.duration;
		durations.durationEstimate -= switchMoveDuration*2;
		if (durations.durationEstimate < 0) {
			durations.durationEstimate = 0;
			console.warn({message:"Duration estimate reached negative value"});
		}
	}
	// // console.log("outStringAdded: " + outString.length);

	commandObjs.forEach(function (cmdObj) {
		if (cmdObj.postCode && lastPlace.length > 0) {
			outString += produceCode(cmdObj, lastPlace[lastPlace.length-1], depthAdjustment, durations, false, false, true);
		}
	});

	// if (commandObj.postCode && lastPlace.length > 0) { // TODO: This assumes the last place is actually used, which is only true for patterns that use all holes
	// 	outString += produceCode(commandObj, lastPlace[lastPlace.length-1], depthAdjustment, durations, false, false, true);
	// }

	let targetTemp = 215;
	if (params["printing temperature"]) { 
		targetTemp = params["printing temperature"];
	}
	outString = outString.replace(/(M10[49] S)(?!0)\d+/g, `$1${targetTemp}`); // Replace setting and waiting for temp with adjusted temperature

	inString += outString;

	return inString;
} 